" Plugins {{{ "

call plug#begin('~/.vim/plugged')

" Plugins helpers
Plug 'mattn/webapi-vim'
Plug 'xolox/vim-misc'
Plug 'russtone/vim-base16-palette'

" Interface
Plug 'justinmk/vim-dirvish'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'

" Navigation
Plug 'yonchu/accelerated-smooth-scroll'
Plug 'christoomey/vim-tmux-navigator'
Plug 'tpope/vim-rsi'

" Search & replace
Plug 'haya14busa/incsearch.vim'
Plug 'osyo-manga/vim-over', { 'on': 'OverCommandLine' }
Plug 'vasconcelloslf/vim-interestingwords'
Plug 'rking/ag.vim', { 'on': 'Ag' }
Plug 'unblevable/quick-scope'
Plug 'easymotion/vim-easymotion'

" Completion
Plug 'Valloric/YouCompleteMe', { 'do': './install.py --clang-completer' }
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'

" Tags
Plug 'xolox/vim-easytags'
Plug 'majutsushi/tagbar'

" Editor
Plug 'tpope/vim-repeat'
Plug 'junegunn/vim-easy-align'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
Plug 'machakann/vim-swap'
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-endwise'

" Text objects
Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-fold'
Plug 'kana/vim-textobj-entire'
Plug 'glts/vim-textobj-comment'
Plug 'kana/vim-textobj-indent'

" Colorschemes
Plug 'chriskempson/base16-vim'

" Wiki
Plug 'vimwiki/vimwiki'

" Git
Plug 'mattn/gist-vim', { 'on': 'Gist' }
Plug 'tpope/vim-fugitive'
Plug 'junegunn/gv.vim', { 'on': 'GV' }

" Linting
Plug 'scrooloose/syntastic'

" CSS
Plug 'hail2u/vim-css3-syntax'
Plug 'groenewege/vim-less'
Plug 'wavded/vim-stylus'

" JavaScript
Plug 'pangloss/vim-javascript'
Plug 'othree/javascript-libraries-syntax.vim'
Plug 'mxw/vim-jsx'

" HTML
Plug 'mattn/emmet-vim', { 'for': 'html' }
Plug 'othree/html5.vim'
Plug 'digitaltoad/vim-jade'
Plug 'tmhedberg/matchit'

" Markdown
Plug 'suan/vim-instant-markdown', { 'for': 'markdown' }

" Toml
Plug 'cespare/vim-toml'

" Go
Plug 'fatih/vim-go', { 'for': 'go' }

" Python
Plug 'hdima/python-syntax'

" C/C++
Plug 'justinmk/vim-syntax-extra'
Plug 'petRUShka/vim-opencl'
Plug 'rhysd/vim-clang-format', { 'for': [ 'c', 'cpp' ] }

" Smali
Plug 'kelwin/vim-smali'

call plug#end()

" }}} Plugins "

" Options {{{ "

" File encodings
set fileencodings=utf-8,cp1251

" Show line numbers (hybrid)
set relativenumber
set number

" Always show status line
set laststatus=2

" Hide status line at the bottom
set noshowmode

" Allow switching buffers without saving
set hidden

" Enable mouse
set mouse=a

" This will cause all yank/delete/paste operations to use the system register *
set clipboard=unnamed,unnamedplus

" Show incomplete commands
set showcmd

" Wildignore
set wildignore=.git,node_modules,build,dist,*.o,*.a,*.pyc,*.class

" Enable syntax highlighting
syntax enable

" Colorscheme
let $NVIM_TUI_ENABLE_TRUE_COLOR=1
set background=dark
" let base16colorspace=256
colorscheme base16-flat
let s:c = base16_palette#flat#colors()
let g:terminal_color = 'xterm'

" Count of spaces per tab when editing
set softtabstop=2

" Number of visual spaces per tab
set tabstop=2

" <<, >> spaces
set shiftwidth=2

" Tabs are spaces
set expandtab

" Display tabs and trailing spaces visually
set list listchars=tab:\ \ ,trail:·

" Mouse and backspace
set backspace=indent,eol,start

" Don't wrap lines
set nowrap

" Count of remembered commands
set history=1000

" Count of undo
set undolevels=1000

" Disable backup files
set nobackup
set nowritebackup

" Disable swap files
set noswapfile

" Case insensitive search
set ignorecase

" Highlight matches
set hlsearch

" Seach while typing
set incsearch

" Detect filetypes
filetype plugin on

" Load filetype-specific indent files
filetype indent on

" Enable folding
set foldenable

" }}} Options "

" Vanilla mappings {{{"

" Rebind leader key to space
let mapleader=' '

" Use jk to exit from insert mode
inoremap jk <Esc>

" Write file
nnoremap <Leader>w :w!<CR>

" Quit
nnoremap <Leader>q :q<CR>

" Select pasted text
noremap gV `[v`]

" Paste in insert mode
inoremap <C-y> <C-o>p

" Disable hlsearch
nnoremap <Leader>l :<C-u>nohlsearch<CR>

" }}} Vanilla mappings "

" Autocmd: vimrc {{{ "

if !exists('*s:ReloadVimrc')
  function! s:ReloadVimrc()
    source $MYVIMRC
    if exists('*s:RefreshStatusLine')
      call s:RefreshStatusLine()
    endif
  endfunction
endif

augroup augroup_vimrc
  autocmd!
  autocmd BufWritePost *vimrc call s:ReloadVimrc()
augroup END

" }}} Autocmd: vimrc "

" Autocmd: vim {{{ "

function! s:VimFilesOptions()
  setlocal foldmethod=marker
endfunction

augroup augroup_vim_files_options
  autocmd!
  autocmd FileType vim call s:VimFilesOptions()
augroup END

" }}} Autocmd: vim "

" Autocmd: SignColumn {{{ "

function! s:ShowSignColumn()
  sign define always_shown_sign
  exec 'sign place 9999 line=1 name=always_shown_sign buffer=' . bufnr('')
endfunction

augroup augroup_always_show_sign_column
  autocmd!
  autocmd BufEnter * call s:ShowSignColumn()
augroup END

" }}} Autocmd: SignColumn "

" Helpers {{{ "

function! s:mode2name(mode)
  let l:mode_map = {
        \ 'n': 'NORMAL',
        \ 'i': 'INSERT',
        \ 'R': 'REPLACE',
        \ 'v': 'VISUAL',
        \ 'V': 'V-LINE',
        \ 'c': 'COMMAND',
        \ "\<C-v>": 'V-BLOCK',
        \ 's': 'SELECT',
        \ 'S': 'S-LINE',
        \ "\<C-s>": 'S-BLOCK',
        \ 't': 'TERMINAL',
        \ '?': ' '
        \ }
  return mode_map[a:mode]
endfunction

function! s:spacewrap(str)
  return ' ' . a:str . ' '
endfunction

" }}} Helpers "

" Statusline {{{1 "

" Colors {{{2 "

exec 'hi StatusLineMode_NORMAL   guibg=' . s:c.gui0D . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_INSERT   guibg=' . s:c.gui0B . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_VISUAL   guibg=' . s:c.gui0A . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_V_LINE   guibg=' . s:c.gui0A . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_V_BLOCK  guibg=' . s:c.gui0A . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_REPLACE  guibg=' . s:c.gui08 . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_COMMAND  guibg=' . s:c.gui09 . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMode_TERMINAL guibg=' . s:c.gui0C . ' guifg=' . s:c.gui01 . ' gui=bold'
exec 'hi StatusLineMiddle        guibg=' . s:c.gui01 . ' guifg=' . s:c.gui07
exec 'hi StatusLineFileType      guibg=' . s:c.gui01 . ' guifg=' . s:c.gui07

" 2}}} Colors "

" Refresh {{{2 "

function! StatusLineBuild(active)
  let l:statusline = ''

  if a:active == 1
    let l:statusline .= '%#StatusLineMode#'
    let l:statusline .= '%{StatusLineMode()}'
    let l:statusline .= '%#StatusLineMiddle#'
  else
  endif

  return l:statusline
endfunction

function! StatusLines()
  return [StatusLineBuild(0), StatusLineBuild(1)]
endfunction


function! StatusLineRefresh()
  let l:statuslines = StatusLines()
  for nr in range(1, winnr('$'))
    let l:active = nr == winnr()
    call setwinvar(nr, '&statusline', l:statuslines[l:active])
  endfor
endfunction

augroup augroup_status_line
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * call StatusLineRefresh()
augroup end

function! Test()
  redrawstatus
  return ''
endfunction

nnoremap : :<C-\>eTest()<CR>

" 2}}} Refresh "

" Mode {{{2 "

function! StatusLineMode()
  let l:modename = s:mode2name(mode())
  let l:filename = expand('%:t')
  let l:filetype = &ft

  if !StatusLineModeHide(l:filename, l:filetype)
    call StatusLineModeColor(l:modename)
    return StatusLineModeText(l:modename)
  endif

  return ''
endfunction

function! StatusLineModeHide(filename, filetype)
  return a:filetype ==# 'help'
endfunction

function! StatusLineModeColor(modename)
  let l:hlsuffix = substitute(a:modename, '-', '_', 'g')
  exec 'hi link StatusLineMode StatusLineMode_' . l:hlsuffix
endfunction

function! StatusLineModeText(modename)
  return ' ' . s:spacewrap(a:modename[0])
endfunction

" 2}}} Mode "

" Branch {{{2 "

function! StatusLineBranch()
  let l:result = ''
  if exists('*fugitive#head')
    let l:result = s:spacewrap(join(['', fugitive#head()]))
    let l:result .= s:StatusLineSeparator('left')
  endif
  return l:result
endfunction

" 2}}} Branch "

" File {{{2 "

function! StatusLineFile()
  let l:fname = expand('%:t')
  let l:result = s:spacewrap(l:fname)
  let l:result .= s:StatusLineSeparator('left')
  return l:result
endfunction

" 2}}} File "

" Filetype {{{2 "

function! StatusLineFileType()
  return '%#StatusLineFileType#' . s:spacewrap(&ft)
endfunction

" 2}}} Filetype "

let g:tagbar_status_func = 'TagbarStatusFunc'
function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return StatusLineBuild(1)
endfunction

" 1}}} Statusline "

" Plugin: UltiSnips {{{ "

let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

" }}} Plugin: UltiSnips "

" Plugin: FZF {{{ "

let g:fzf_layout = { 'down': '~30%' }

" Go to file
nnoremap <Leader>f :Files<CR>

" Go to tag in project
nnoremap <Leader>g :Tags<CR>

" Go to tag in buffer
nnoremap <Leader>e :BTags<CR>

" Search with ag
nnoremap <leader>/ :execute 'Ag ' . input('Ag/')<CR>

" Go to buffer
nnoremap <Leader>c :Buffers<CR>

" }}} Plugin: FZF "

" Plugin: lightline.vim {{{ "

" Update lightline
function! s:lightline_update()
  if !exists('g:loaded_lightline')
    return
  endif
  try
    call lightline#init()
    call lightline#colorscheme()
    call lightline#update()
  catch
  endtry
endfunction

let s:c = base16_palette#flat#colors()

let s:p = {
      \ 'normal': {},
      \ 'insert': {},
      \ 'replace': {},
      \ 'visual': {},
      \ 'inactive': {}
      \ }

let s:p.normal.left   = [ [ s:c.gui01, s:c.gui0D, s:c.cterm01, s:c.cterm0D, 'bold' ] ]
let s:p.normal.middle = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01 ] ]
let s:p.normal.right  = [ [ s:c.gui01, s:c.gui0D, s:c.cterm01, s:c.cterm0D, 'bold' ] ]

let s:p.insert.left   = [ [ s:c.gui01, s:c.gui0B, s:c.cterm01, s:c.cterm0B, 'bold' ] ]
let s:p.insert.middle = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01 ] ]
let s:p.insert.right  = [ [ s:c.gui01, s:c.gui0B, s:c.cterm01, s:c.cterm0B, 'bold' ] ]

let s:p.replace.left   = [ [ s:c.gui01, s:c.gui08, s:c.cterm01, s:c.cterm08, 'bold' ] ]
let s:p.replace.middle = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01 ] ]
let s:p.replace.right  = [ [ s:c.gui01, s:c.gui08, s:c.cterm01, s:c.cterm08, 'bold' ] ]

let s:p.visual.left   = [ [ s:c.gui01, s:c.gui0A, s:c.cterm01, s:c.cterm0A, 'bold' ] ]
let s:p.visual.middle = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01 ] ]
let s:p.visual.right  = [ [ s:c.gui01, s:c.gui0A, s:c.cterm01, s:c.cterm0A, 'bold' ] ]

let s:p.inactive.left   = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01, 'bold' ] ]
let s:p.inactive.middle = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01 ] ]
let s:p.inactive.right  = [ [ s:c.gui06, s:c.gui01, s:c.cterm06, s:c.cterm01, 'bold' ] ]

let g:lightline#colorscheme#base16_flat#palette = s:p

let g:lightline = {
      \ 'colorscheme': 'base16_flat',
      \ 'active': {
      \   'left': [
      \     [ 'mode', 'paste' ],
      \     [ 'branch' ]
      \   ],
      \   'right': []
      \ },
      \ 'inactive': {
      \   'left': [],
      \   'right': []
      \ },
      \ 'component_function': {
      \   'mode': 'LightLineMode',
      \   'paste': 'LightLinePaste',
      \   'branch': 'LightLineBranch',
      \   'tagbar': 'LightLineTagbar'
      \ },
      \ 'separator': { 'left': '', 'right': ''},
      \ 'subseparator': { 'left': '|', 'right': '|' },
      \ }

function! LightLineTagbar()
  return expand('%:t') ==# '__Tagbar__' ? 'Tagbar' : ''
endfunction

function! LightLineMode()
  if winwidth(0) < 20
    return ''
  endif
  let l:fname = expand('%:t')
  if l:fname ==# '__Tagbar__'
    return 'Tagbar'
  endif
  return lightline#mode()[0]
endfunction

function! LightLinePaste()
  return &paste ? 'P' : ''
endfunction

" let g:tagbar_status_func = 'TagbarStatusFunc'
" function! TagbarStatusFunc(current, sort, fname, ...) abort
"     let g:lightline.fname = a:fname
"   return lightline#statusline(0)
" endfunction

function! LightLineBranch()
  if !exists('*fugitive#head')
    return ''
  endif
  let l:fname = expand('%:t')
  if l:fname =~? 'Tagbar'
    return ''
  endif
  let l:branch = fugitive#head()
  return strlen(branch) ? join(['', l:branch]) : ''
endfunction

function! LightLineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightLineReadonly()
  return &ft !~? 'help' && &readonly ? '' : ''
endfunction

" }}} Plugin: lightline.vim "

" Plugin: YouCompleteMe {{{ "

let g:ycm_key_detailed_diagnostics = ''
let g:ycm_global_ycm_extra_conf = '~/.vim/.ycm_extra_conf.py'
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_complete_in_comments = 1
let g:ycm_complete_in_strings = 1
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_key_invoke_completion = '<c-x><c-o>'
" let g:ycm_show_diagnostics_ui = 0

" Autocomplete triggers
let g:ycm_semantic_triggers = {
      \ 'css': [ 're!^\s{2}', 're!:\s+' ],
      \ 'less': [ 're!^\s{2,}', 're!:\s+' ],
      \ 'stylus': [ 're!^\s{2,}', 're!:\s+' ]
      \ }

" }}} YouCompleteMe "

" Plugin: syntastic {{{ "

" Ignore angular attributes in html
let g:syntastic_html_tidy_ignore_errors = [
      \ " proprietary attribute \"ng-",
      \ " proprietary attribute \"ui-",
      \ ]

" Better :sign interface symbols
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠︎'

" JS
let g:syntastic_javascript_checkers = ['eslint']

let g:syntastic_check_on_wq = 0

" }}} Plugin: syntastic "

" Plugin: incsearch.vim {{{ "

" Use incsearch instead default search
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)

" Auto disable highlighting
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <PLug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)

" Additional mappings in command mode
let g:incsearch_cli_key_mappings = {
      \ "\<Tab>": {
      \   'key': '<Over>(buffer-complete)',
      \   'noremap': 1
      \ },
      \ "\<C-j>": "\<CR>",
      \ }

" }}} Plugin: incsearch.vim "

" Plugin: vim-over {{{ "

vnoremap <silent> gR :OverCommandLine<cr>s/\%V
vnoremap <silent> gr :OverCommandLine<cr>s/
nnoremap <silent> gr :OverCommandLine<cr>s/

" }}} Plugin: vim-over "

" Plugin: vim-easy-align {{{ "

vnoremap ga :EasyAlign<space>

" }}} Plugin: vim-easy-align "

" Plugin: vim-jsx {{{ "

" Enable jsx highlighting for js files
let g:jsx_ext_required = 0

" }}} Plugin: vim-jsx "

" Plugin: NERDTree {{{ "

let g:NERDTreeMapMenu = ','
let g:NERDTreeRespectWildIgnore = 1
let g:NERDTreeMinimalUI = 1
map <leader><leader> :NERDTreeToggle<cr>

" }}} Plugin: NERDTree "

" Plugin: vim-quick-scope {{{ "

" Trigger a highlight in the appropriate direction when pressing these keys:
let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']

" }}} Plugin: vim-quick-scope "

" Plugin: vim-easytags {{{ "

" Create tags file in project dir (instead of file dir)
set cpo+=d

" Tags file name '.tags' in project dir
set tags=./.tags

" No global tags file
let g:easytags_file = ''

" Create tags file if not exist
let g:easytags_dynamic_files = 2

" Disable auto update tags file (manual update)
let g:easytags_on_cursorhold = 0
let g:easytags_always_enabled = 0
let g:easytags_events = []

" Mapping for manual tags update
nnoremap <leader>u :UpdateTags<cr>

" }}} Plugin: vim-easytags "

" Plugin: python-syntax {{{ "

let g:python_highlight_all = 1

" }}} Plugin: python-syntax "

" Plugin: vimwiki {{{ "

let wiki = {}
let wiki.path = '~/vimwiki/'
let wiki.css_name = '~/vimwiki/style.css'
let wiki.nested_syntaxes = {'python': 'python', 'c++': 'cpp', 'make': 'make'}
let g:vimwiki_list = [wiki]

" }}} Plugin: vimwiki "

" Plugin: vim-instant-markdown {{{ "

let g:instant_markdown_autostart = 0

" }}} Plugin: vim-instant-markdown "

" Plugin: vim-less {{{ "

augroup LessAutocmd
autocmd!
autocmd FileType less nnoremap <leader>p :w <bar> !lessc % > %:gs?less?css?:p<cr><space>
autocmd FileType less set omnifunc=csscomplete#CompleteCSS
augroup END

" }}} Plugin: vim-less "

" Plugin: vim-stylus {{{ "

augroup StylusAutocmd
autocmd!
autocmd FileType stylus set omnifunc=csscomplete#CompleteCSS
augroup END

" }}} Plugin: vim-stylus "

" Plugin: tagbar {{{ "

" Toggle tagbar
nnoremap <leader>t :TagbarToggle<cr>

let g:tagbar_autofocus = 1
let g:tagbar_compact = 1
let g:tagbar_autoshowtag = 1

" Tags for Go
let g:tagbar_type_go = {
      \ 'ctagstype' : 'go',
      \ 'kinds'     : [
      \   'p:package',
      \   'i:imports:1',
      \   'c:constants',
      \   'v:variables',
      \   't:types',
      \   'n:interfaces',
      \   'w:fields',
      \   'e:embedded',
      \   'm:methods',
      \   'r:constructor',
      \   'f:functions'
      \ ],
      \ 'sro' : '.',
      \ 'kind2scope' : {
      \   't' : 'ctype',
      \   'n' : 'ntype'
      \ },
      \ 'scope2kind' : {
      \   'ctype' : 't',
      \   'ntype' : 'n'
      \ },
      \ 'ctagsbin'  : 'gotags',
      \ 'ctagsargs' : '-sort -silent'
      \ }

" }}} Plugin: tagbar "

" Plugin: vim-ag {{{ "

nnoremap <leader>a :Ag<space>

" }}} Plugin: vim-ag "

" Plugin: vim-clang-format {{{ "

let g:clang_format#code_style = 'google'

" Common style options
let g:clang_format#style_options = {
  \ }

" Filetype specific options
let g:clang_format#filetype_style_options = {
  \ 'cpp' : {
  \ },
  \ 'c' : {
  \ },
  \ }

" }}} Plugin: vim-clang-format "

" Plugin: vim-surround {{{ "

" Surround with single/double quiote
nmap g' ysiW'
nmap g" ysiW"

" }}} Plugin: vim-surround "

" Plugin: EasyMotion {{{ "

" Disable default mappings
let g:EasyMotion_do_mapping = 0

" Turn on case insensitive feature
let g:EasyMotion_smartcase = 1

" Press 2 keystrokes and jump
nmap s <Plug>(easymotion-overwin-f2)

" Smartsign (type `3` and match `3`&`#`)
let g:EasyMotion_use_smartsign_us = 1

" JK motions: Line motions
map <Leader>l <Plug>(easymotion-lineforward)
map <Leader>h <Plug>(easymotion-linebackward)
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

" }}} Plugin: EasyMotion "
